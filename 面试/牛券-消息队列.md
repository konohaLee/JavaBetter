## 为什么选择使用rockermq
主要对比了 `Kafka` 和 `RocketMQ`。虽然两者都是高吞吐、高可用的优秀产品，但我们最终选择 `RocketMQ`，主要是因为它在**业务功能契合度**上更贴合我们场景。
首先，`RocketMQ` 提供了 `Kafka` 缺失的、但对我们业务**刚需**的功能：
- **延迟消息（定时消息）：** 在我们的业务中，有大量需要‘延迟处理’的场景，‘优惠券到期设置为过期’。`RocketMQ` 原生支持（5.x后）任意精度的延迟消息，使用起来非常简单。而 `Kafka` 没有这个功能，如果用它实现，我们就必须自己开发一套复杂的定时调度系统（比如多topic轮询），维护成本很高。
## 使用了消息队列，可靠性怎么保证
在使用消息队列 RocketMQ 实现异步化、解耦、削峰等功能的情况下，我们认为消息中间件是一个可靠的组件，这里的可靠性指的是，只要消息被成功投递到了消息中间件，它就不会丢失，至少能够被消费者成功消费一次。这是消息中间件最基本的特性之一，也就是我们通常所说的 **“AT LEAST ONCE”**，即消息至少会被成功消费一遍。
是由**生产者、Broker（服务端）和消费者**三个阶段的多种机制共同构成的。
简单来说，`RocketMQ` 的可靠性模型是：**"Broker 保证消息不丢，但允许消息重复，由消费者自行实现幂等"**。
### 1. 生产者（Producer）阶段：保证消息“成功发出”

这一阶段的目标是：**确保消息从生产者的服务器，成功发送到了 Broker 服务器。**

- 1. 同步发送（Sync Send）
    
    这是最可靠的发送方式。当生产者调用 send 方法时，它会阻塞当前线程，直到 Broker 返回一个明确的 ACK（确认）响应。如果 Broker 返回成功，生产者就能 100% 确定消息已经到达 Broker。如果返回异常（或超时），生产者就可以进行处理（如下一步）。
    
- 2. 发送重试（Retry）
    
    如果生产者没有收到 Broker 的 ACK（比如因为网络抖动导致超时），它不会立即放弃。RocketMQ 的 Producer 内部会自动进行重试（默认2次）。这个机制能极大地对抗网络瞬时故障，提高发送成功率。
    
- 3. 异步发送（Async Send）
    
    对于需要高吞吐量的场景，生产者可以使用“异步发送”。它不会阻塞线程，而是提供一个回调函数（Callback）。RocketMQ 在收到 Broker 的 ACK 后，会自动调用你的 onSuccess 或 onException 方法。可靠性体现在：你必须在这两个回调方法中编写逻辑，来确认消息是否发送成功（比如记录日志、报警或存入本地重试表）。
### 2. Broker（服务端）阶段：保证消息“安全存储”

这是**最关键**的阶段。目标是：**`Broker` 收到消息后，必须保证消息在服务器上不丢失。**

`RocketMQ` 通过“**刷盘机制**”和“**主从复制**”两种方式来保证。

- 1. 刷盘机制（Flush to Disk）
    
    Broker 收到消息后，是先存内存还是先存硬盘？
    
    - a. 同步刷盘（高可靠）
        
        Broker 收到消息后，必须立刻将消息（写入 CommitLog 文件）并强制刷入物理磁盘，然后才向生产者返回 ACK。
        
        - **优点**：可靠性最高。即使 `Broker` 所在的服务器**突然断电**，由于消息已经在磁盘上了，重启后数据也不会丢失。
            
        - **缺点**：性能较低，因为每次都要等待磁盘 I/O。
            
    - b. 异步刷盘（高性能）
        
        Broker 收到消息后，会先把消息写入操作系统的页缓存（Page Cache，在内存中），然后立刻向生产者返回 ACK。之后再由一个后台线程异步地将内存中的数据刷到磁盘。
        
        - **优点**：性能极高，几乎是纯内存操作。
            
        - **缺点**：有丢失数据的风险。如果服务器在**刷盘前**断电，`Page Cache` 里的数据就会丢失。
            
- 2. Broker 主从复制（Broker Replication）
    
    刷盘只能解决单机断电问题，如果这台机器的磁盘坏了怎么办？这就需要主从复制。
    
    - a. 同步复制（高可靠）
        
        Broker 以**一主多从（Master/Slave）**模式部署。
        
        1. 生产者将消息发送给 `Master`。
            
        2. `Master` 收到后，**将消息同步**给 `Slave`。
            
        3. `Slave` 也写入成功，**向 `Master` 返回 `ACK`**。
            
        4. `Master` 收到 `Slave` 的 `ACK` 后，**才向生产者返回最终的 `ACK`**。
            
        
        - **优点**：可靠性极高。这保证了在生产者收到“成功”时，消息**至少在两台不同机器上**都存储了。`Master` 彻底宕机（比如机房火灾），`Slave` 仍有完整数据，消息不丢失。
            
        - **缺点**：性能下降，因为网络I/O多了一轮。
            
    - b. 异步复制（高性能）
        
        Master 收到消息并（同步/异步）刷盘后，立刻向生产者返回 ACK，然后再异步地把消息复制给 Slave。
        
        - **优点**：性能高。
            
        - **缺点**：有丢失风险。如果 `Master` 在**复制给 `Slave` 之前**宕机，这条消息就丢失了。
            

**可靠性组合**：在金融级场景下，最可靠的配置是 **`同步复制` + `同步刷盘`**。

### 3. 消费者（Consumer）阶段：保证消息“一定被处理”

这一阶段的目标是：**确保消息被消费者成功处理，防止消息在处理过程中丢失。**

`RocketMQ` 在这一阶段提供的是 **`At-Least-Once`（至少一次）** 的投递语义。

- 1. ACK 确认机制
    
    RocketMQ 的消费是拉（Pull）模式。消费者主动向 Broker 拉取一批消息。
    
    1. 消费者拉取消息到本地内存（比如 32 条）。
        
    2. 消费者**执行自己的业务逻辑**（比如：写数据库、调用RPC）。
        
    3. 业务逻辑**全部执行成功**后，消费者才向 `Broker` **发送一个 `ACK`（消费确认）**。
        
    4. `Broker` 收到 `ACK` 后，才会移动**消费位点（Offset）**，标记这批消息“已被消费”。
        
- 2. 消费重试（Retry）与幂等
    
    这是可靠性的关键体现：
    
    - **如果消费者宕机了**：消费者在执行业务逻辑时（第2步）突然宕机，它**没有机会**发送 `ACK`。
        
    - **如果业务执行失败**：消费者在执行业务时（第2步）抛出异常（比如数据库连接失败），它会**主动返回一个“消费失败”**给 `Broker`（也不会发送 `ACK`）。
        
    
    在这两种情况下，Broker 没有收到 ACK，因此消费位点（Offset）不会移动。
    
    当 Broker 稍后（或集群中其他消费者）再次拉取时，它会重新投递这批消息。
    
    这就带来了“重复消费”问题。比如消费者业务逻辑执行成功，但在发 ACK 前宕机了，它就会收到第二遍。
    
    因此，RocketMQ 强制要求：消费者的业务逻辑必须由开发者自己保证“幂等”（就像你上一节课实现的幂等组件那样），以确保消息被重复处理时不会产生副作用。
## 消息队列业务幂等性问题
>举个例子，假设一个消息 M 被发送到消息中间件并被消费程序 A 接收到，A 开始消费这个消息，但是在消费过程中程序重启了。由于这个消息没有被标记为已经被消费成功，消息中间件会持续地将这个消息投递给消费者，直到消息被成功消费为止。
>然而，这种可靠性特性也会导致消息被多次投递的情况。举个例子，仍然以之前的例子为例，如果消费程序 A 接收并完成消息 M 的消费逻辑后，正准备通知消息中间件“我已经消费成功了”，但在此之前程序A又重启了，那么对于消息中间件来说，这个消息 M 并没有被成功消费过，因此消息中间件会继续投递这个消息。而对于消费程序A来说，尽管它已经成功消费了这个消息，但由于程序重启导致消息中间件继续投递，看起来就好像这个消息还没有被成功消费过一样。

***也就是说，消费者消费完了没来得及返回消费结果就宕机了，会被认为没有消费，消息队列为了确保消息被消费会重复发送消息，那么就造成了重复消费的场景***
在 RockectMQ 的场景中，这意味着同一个 messageId 的消息会被重复投递。由于消息的可靠投递是更重要的，所以避免消息重复投递的任务转移给了应用程序自身来实现。这也是 RocketMQ 文档强调***消费逻辑需要自行实现幂等性的原因***。实际上，这背后的逻辑是：在分布式场景下，保证消息不丢和


这套方案**非常巧妙**，它**不依赖数据库事务**，而是通过 **AOP + 自定义注解 + Redis + Lua脚本** 组合，实现了一个高性能、通用的幂等组件。

### 核心思想

这套方案的核心是**在 `Redis` 中为每一条消息设置一个“状态锁”**。它定义了两种状态：
1. **`CONSUMING` (消费中，值为 "0")**：代表一个消费者线程正在处理这条消息。
2. **`CONSUMED` (已消费，值为 "1")**：代表这条消息已经被成功处理完毕。
它通过 AOP 拦截消息消费方法，在**执行业务逻辑前**抢占这个“状态锁”，在**执行后再**更新锁的状态，从而保证幂等。
### 实现步骤详解
#### 1. 自定义注解 (`@NoMQDuplicateConsume`)
首先，定义一个注解，用来标记“哪些消费者方法需要幂等”。
```
@Target(ElementType.METHOD)
@Retention(Retention.RUNTIME)
public @interface NoMQDuplicateConsume {
    String keyPrefix() default ""; // 幂等Key的前缀
    String key();                  // SpEL表达式，用于生成唯一Key
    long keyTimeout() default 3600L; // 锁的超时时间
}
```

- `key()` 是最重要的，它通过 **SpEL 表达式**从消息体中提取唯一标识（比如 `couponTaskId`），确保同一条消息的 `key` 始终不变。
#### 2. AOP 切面 (`NoMQDuplicateConsumeAspect`)
这是所有逻辑的核心。它使用 `@Around` 环绕注解，拦截所有标记了 `@NoMQDuplicateConsume` 的方法。
以下是当一条消息到达时，AOP 切面中的**完整执行流程**：
第 1 步：生成唯一 Key
AOP 首先解析注解，通过 SpEL 表达式生成一个全局唯一的 uniqueKey。
（例如：keyPrefix + key = coupon_task_execute:idempotent:task12345）
第 2 步：执行 Lua 脚本（原子性的“检查与设置”）
这是最关键的一步。AOP 会执行一个 Redis 的 Lua 脚本来尝试“占锁”。
```
-- Lua 脚本
local key = KEYS[1]         -- 唯一Key (uniqueKey)
local value = ARGV[1]       -- "0" (CONSUMING 状态)
local expire_time_ms = ARGV[2] -- 超时时间（比如 10 分钟）

-- 核心命令：
-- 'NX': 只在 Key 不存在时才设置
-- 'GET': 在设置前，返回旧值
-- 'PX': 设置毫秒级过期时间
return redis.call('SET', key, value, 'NX', 'GET', 'PX', expire_time_ms)
```

第 3 步：AOP 分析 Lua 脚本的返回值 (absentAndGet)

Lua 脚本的返回值决定了接下来的所有行为：

- **情况 A：`absentAndGet == null` (nil)**
    - **含义**：`Key` 不存在。`SET ... 'NX'` 执行成功。
    - **结果**：`Redis` 中成功写入了 `uniqueKey = "0"` (消费中)，并设置了过期时间。
    - **动作**：这是**消息第一次被消费**。AOP 会继续执行**第 4 步**。
- **情况 B：`absentAndGet == "0"` (CONSUMING)**
    - **含义**：`Key` 已存在，且值是 "0"。
    - **结果**：这说明**有另一个线程正在处理**这条消息。
    - **动作**：AOP **抛出一个 `ServiceException`**。在 `RocketMQ` 场景下，抛出异常会导致消费失败，消息会**自动进入重试（延迟消费）**，防止并发穿透。
- **情况 C：`absentAndGet == "1"` (CONSUMED)**
    - **含义**：`Key` 已存在，且值是 "1"。
    - **结果**：这说明这条消息**已经被成功消费过了**。
    - **动作**：AOP **直接返回 `null`**（或 `void`），**不执行**业务逻辑，也不抛异常。消息被**“幂等”**掉了。

第 4 步：执行真正的业务逻辑（只在情况 A 发生）

AOP 调用 joinPoint.proceed()，即执行 CouponTaskExecuteConsumer 中 onMessage 方法的实际业务代码。

**第 5 步：处理业务逻辑的结果**

- **如果业务逻辑执行成功（`proceed()` 正常返回）**：
    
    - **动作**：AOP 会执行 `stringRedisTemplate.opsForValue().set(uniqueKey, "1", ...)`。
        
    - **含义**：将 `Redis` 中的 `Key` 从 "0"（消费中）**更新为 "1"（已消费）**，并重置过期时间。下次再有重复消息进来，就会命中**情况 C**。
        
- **如果业务逻辑执行失败（`proceed()` 抛出异常）**：
    
    - **动作**：AOP 的 `catch` 块会捕获异常，并执行 `stringRedisTemplate.delete(uniqueKey)`。
        
    - **含义**：**删除这个幂等 Key**。
        
    - **为什么删除**：因为业务执行失败了，`RocketMQ` 稍后会重试。如果 `Key`（值是 "0"）不删除，重试时就会命中**情况 B**，导致永远无法重试。删除 `Key` 后，下一次重试就能重新回到**情况 A**。
        

### 为什么设置 Key 的超时时间？

这是为了**防止“死锁”**。

- **场景**：假设一个消费者在**情况 A** 中成功将 `Key` 设置为 "0"（消费中），但在执行**第 4 步**业务逻辑时，服务**突然宕机**了。
    
- **问题**：这个 `Key` 的值**永远是 "0"**，它既没有机会被更新为 "1"，也没有机会被 `catch` 块删除。
    
- **后果**：后续所有对这条消息的重试，都会命中**情况 B**（消费中），导致消息**永远无法被消费**（最终进入死信队列）。
    
- **解决方案**：在**第 2 步** `Lua` 脚本设置 `Key` 时，就给它一个**最长消费过期时间**（比如文档中说的 10 分钟或 2 分钟）。这样，即使消费者宕机，这个 "0" 的锁也会在 10 分钟后**自动释放**，允许 `RocketMQ` 的下一次重试重新进入流程。