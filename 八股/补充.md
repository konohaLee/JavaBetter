
## 1.MySQL 的两阶段提交

想象一下，您是 MySQL 数据库，您有两个“账本”必须时刻保持一致，**一丁点差错都不能出**。

1. **账本 A (InnoDB)：** 这是您的“**底账**”（`redo log` 和数据页）。它记录了您自己（主数据库）的数据到底变成了什么样。
    
2. **账本 B (Binlog)：** 这是您要“**寄给分店**”（从库/Slaves）的“**操作流水**”。分店需要靠这个账本来和您（主库）保持一模一样。
    

### 1. 为什么需要它？（问题的起源）

如果这是一个简单的单机系统，您只需要“账本A”就够了。但因为有了“分店”（复制/Replication），您就必须同时写两个账本。

这时，一个**致命的问题**出现了：如果您在写这两个账本的**中间**，服务器**突然断电（Crash）**了，会发生什么？

- **情况一：先写 InnoDB (底账)，再写 Binlog (流水)**
    
    - 您刚写完“底账”，数据已经改了。
        
    - **CRASH!**
        
    - 您还没来得及写“流水”。
        
    - **后果：** 重启后，主库（您）数据变了，但因为“流水”丢了，所有“分店”（从库）**永远收不到这个更新**。主从数据不一致，这是灾难。
        
- **情况二：先写 Binlog (流水)，再写 InnoDB (底账)**
    
    - 您刚写完“流水”。
        
    - **CRASH!**
        
    - 您还没来得及改“底账”。
        
    - **后果：** 重启后，“分店”从“流水”里拿到了更新，**它们改了数据**。但主库（您）因为“底账”没改，**数据还是旧的**。主从数据不一致，这更是灾难。
        

您看，无论谁先谁后，只要在中间出事，数据一致性就全毁了。

### 2. “两阶段提交”如何解决？（精妙的设计）

为了解决这个“要么都成功，要么都失败”的原子性问题，MySQL 引入了一个“**仪式感**”超强的提交流程。它不再是“直接写”，而是“**先准备，再确认**”。

这个过程，在 MySQL 内部（Server 层和 InnoDB 引擎层之间），被称为**内部 XA 事务**或**两阶段提交**。

**阶段一：Prepare (准备阶段) - “一切就位，只等我发令”**

当您（MySQL）执行一个 `COMMIT` 时，它不会立即提交，而是：

1. （对 InnoDB 说）：“喂，准备一下，把这个事务（比如 `update user set age = 19 where id = 1`）所需要的所有数据和日志（`redo log`）都**写好、落盘**。”
    
2. `InnoDB` 引擎开始工作，它把 `redo log` 写入磁盘，但**在内存中把这个事务标记为 `PREPARED`（准备就绪）状态**。
    
3. （`InnoDB` 回复）：“老板，我这边OK了。随时可以提交，也随时可以撤销。听您指令。”
    

**请注意：** 此时 `InnoDB` 事务**还没有真正提交**。它只是处在一个“万事俱备，只欠东风”的中间状态。

**阶段二：Commit (提交阶段) - “发令！写入流水！”**

1. MySQL Server（老板）收到 `InnoDB` 的“准备好了”的回复后，它**立刻去做第二件、也是最关键的事：写 Binlog (账本B)**。
    
2. `Binlog` 被成功写入磁盘。
    
3. **（关键点）** 一旦 `Binlog` 写入成功，MySQL Server 就认为这个事务**“在逻辑上”已经成功了**（因为“分店”的流水已经确保了）。
    
4. （MySQL Server 再对 InnoDB 说）：“OK，`Binlog` 写完了。你那边（`InnoDB`）可以**正式提交**了。”
    
5. `InnoDB` 收到指令，把内存中那个“PREPARED”的事务标记为 `COMMIT`，释放锁，事务正式完成。
    

### 3. 为什么这样就安全了？（Crash 后的恢复）

这个设计的精妙之处，不在于它不出错，而在于**它出错了也能完美恢复**。

我们来看看刚才的“断电”问题，在两阶段提交下会怎样：

当服务器重启后，MySQL 会开始“**灾后重建**”（Crash Recovery）。它会检查所有处于 `PREPARED` 状态的事务。

**检查方式：** 它会去拿 `InnoDB` 中 `PREPARED` 状态的事务，去 `Binlog` 里**核对**。

- **情况一：Crash 发生在“准备阶段” (Phase 1)**
    
    - MySQL 发现 `InnoDB` 里有个事务是 `PREPARED` 状态，但**在 `Binlog` 里找不到对应的流水**。
        
    - **MySQL 判断：** “哦，看来我是在‘写流水’之前就挂了。”
        
    - **恢复动作：** **回滚 (Rollback)** 这个 `InnoDB` 事务。
        
    - **结果：** `InnoDB`（底账）和 `Binlog`（流水）都没有这个记录。数据完美一致。
        
- **情况二：Crash 发生在“提交阶段” (Phase 2)**
    
    - MySQL 发现 `InnoDB` 里有个事务是 `PREPARED` 状态，**在 `Binlog` 里也找到了对应的流水**。
        
    - **MySQL 判断：** “哦，看来‘流水’已经写了，我是在命令 `InnoDB` 正式提交前挂了。”
        
    - **恢复动作：** **提交 (Commit)** 这个 `InnoDB` 事务。
        
    - **结果：** `InnoDB`（底账）和 `Binlog`（流水）都有了这个记录。数据完美一致。
        

---

### 总结（两者的有机结合）

**两阶段提交 (2PC)**，本质上不是一个性能工具，而是一个**强一致性保障机制**。

它在 MySQL 内部，充当了“事务协调器”的角色，协调的是 `InnoDB` 引擎（`redo log`）和 `Binlog` 这两个“必须保持一致”的参与者。

它通过引入一个“**准备状态 (PREPARED)**”作为缓冲，强行制造了一个“**决策点**”——**`Binlog` 是否写入成功**。

- `Binlog` 写入**前**出事，就一起**回滚**。
    
- `Binlog` 写入**后**出事，就一起**提交**。
    

通过这种方式，MySQL 巧妙地保证了，无论在哪个时间点发生崩溃，**只要 `binlog` 是开启的**，它的本地数据（`InnoDB`）和用于复制的流水（`binlog`）在恢复后，**永远是100%匹配的**。这就是它设计的全部意义。
## delete drop truncate区别
### delete
delete 属于数据库操纵语言DML，表示删除表中的数据。

DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。

delete 既可以对table也可以对view，可以全部删除，也可以按条件删除。

语法：
– 删除表中全部数据
delete from 表名
– 按条件删除
delete from 表名 where 条件

使用 DELETE 语句能删除表中的行。例如，下面的语句删除 employee 表中的所有行：
DELETE FROM employee;

### drop
drop 属于数据库定义语言DDL，表示删除表， 也可以用来删除数据库。

语法：
– 删除 表
drop table 表名
– 删除数据库
drop database 数据库名

使用 DROP 删除一个表，然后创建一个同名的表，也可以达到清空表的效果。例如，下面的语句先删除 employe 表，之后再重新创建。
DROP TABLE EMPLOYEE;
CREATE TABLE EMPLOYEE(…);
当删除和重新创建表时，所有与之相关联的索引、完整性约束和触发器也被删除。同样，所有针对被删除表的授权也会被删除。

### truncate
truncate 属于数据库定义语言DDL，表示删除表中所有数据。
truncate 只能对table，执行速度快
语法：
– 删除表中所有数据且不可恢复
truncate table 表名

使用 TRUNCATE 语句能删除表中的所有行。例如，下面的语句清空 employee 表。
TRUNCATE TABLE EMPLOYEE;

TRUNCATE 语句为我们提供了一种快速、有效地删除表所有行的方法。并且 TRUNCATE 是一个 DDL 语句，不会产生任何回滚信息。执行 TRUNCATE 会立即提交，而且不能回滚。
TRUNCATE 语句并不影响与被删除的表相关联的任何结构、约束、触发器或者授权。

### 相同点
1.truncate和不带where子句的delete、以及drop都会删除表内的数据。

2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。

### 区别
1.执行速度，一般来说： drop> truncate > delete
2.delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交
3.TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）
4.truncate、drop是DLL,操作立即生效，原数据不放到 rollback segment中，不能回滚，delete可以回滚
5.对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。
6.TRUNCATE TABLE 不能用于参与了索引视图的表。